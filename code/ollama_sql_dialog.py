# # -*- coding: utf-8 -*-
# """
# /***************************************************************************
#  OllamaChatPluginDialog
#                                  A QGIS plugin
#  AI SQL Generator using Ollama
#  Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
#                              -------------------
#         begin                : 2025-11-19
#         git sha              : $Format:%H$
#         copyright            : (C) 2025 by Lama Shraim
#         email                : s12218623@stu.najah.edu
#  ***************************************************************************/

# /***************************************************************************
#  *                                                                         *
#  *   This program is free software; you can redistribute it and/or modify  *
#  *   it under the terms of the GNU General Public License as published by  *
#  *   the Free Software Foundation; either version 2 of the License, or     *
#  *   (at your option) any later version.                                   *
#  *                                                                         *
#  ***************************************************************************/
# """


import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
import requests
import psycopg2
from qgis.PyQt.QtWidgets import QMessageBox
from qgis.core import QgsVectorLayer

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ollama_sql_dialog_base.ui'))


class OllamaChatPluginDialog(QtWidgets.QDialog, FORM_CLASS):


    def __init__(self, parent=None):
        """Constructor."""
        super(OllamaChatPluginDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.db_host = "localhost"
        self.db_port = "5432"
        self.db_name = "jenbarry_db2" # db ndame 
        self.db_user = "postgres"        #username
        self.db_pass = "password"

        self.btnSend.clicked.connect(self.send_to_ollama)
        self.btnExecuteSQL.clicked.connect(self.execute_preview_sql)



    def get_schema_info(self):
        try:
            conn = psycopg2.connect(
                host=self.db_host, port=self.db_port, dbname=self.db_name,
                user=self.db_user, password=self.db_pass
            )
            cursor = conn.cursor()

            cursor.execute("""
                            SELECT table_name, column_name
                            FROM information_schema.columns
                            WHERE table_schema NOT IN ('pg_catalog', 'information_schema')
                            AND table_name NOT IN ('geometry_columns', 'geography_columns', 'spatial_ref_sys')
                            ORDER BY table_name, ordinal_position;
                        """)
            rows = cursor.fetchall()
            cursor.close()
            conn.close()

            tables = {}
            for table, column in rows:
                if table not in tables:
                    tables[table] = []
                tables[table].append(column)

            schema_text = ""
            for table, columns in tables.items():
                schema_text += f"Table: {table}\n"
                for col in columns:
                    schema_text += f"  - {col}\n"
                schema_text += "\n"

            return schema_text

        except Exception:
            return ""



    def send_to_ollama(self):

        user_text = self.txtInput.toPlainText().strip()

        if not user_text:
            QMessageBox.warning(self, "Warning", "Please enter a question.")
            return

        try:
            url = "http://localhost:11434/api/generate"
            schema_info = self.get_schema_info()
            payload = {
                "model": "phi3",
                "prompt":  "Your job is to write a valid PostgreSQL statement based only "
                        "on the existing tables and columns shown below. "
                        "Do NOT invent or guess any tables or columns. "
                        "Return ONLY the SQL with no comments or explanation.\n\n"
                        "Database Schema:\n"
                        f"{schema_info}\n"
                        f"User question: {user_text}",
                "stream": False
            }

            response = requests.post(url, json=payload)

            if response.status_code == 200:
                data = response.json()
                generated_text = data.get("response", "").strip()
                generated_sql = self._sanitize_sql(generated_text)

                # Safety check 
                if any(word in generated_sql.lower() for word in ["drop ", "delete ", "truncate "]):
                    QMessageBox.critical(self, "Blocked", "Dangerous SQL was detected.")
                    return

                # Put SQL in the preview box
                self.txtSQLPreview.setPlainText(generated_sql)


            else:
                QMessageBox.critical(self, "Error", f"Request failed: {response.text}")


        except Exception as e:
            QMessageBox.critical(self, "Error", str(e))


    def _sanitize_sql(self, text):
        text = text.replace("```sql", "").replace("```", "").strip()
        return text


    def execute_preview_sql(self):
        sql_query = self.txtSQLPreview.toPlainText().strip()
        if not sql_query:
            QMessageBox.warning(self, "Warning", "No SQL to execute.")
            return
        self.execute_sql(sql_query)


    def execute_sql(self, sql_query):
        try:
            conn = psycopg2.connect(
                host=self.db_host,
                port=self.db_port,
                dbname=self.db_name,
                user=self.db_user,
                password=self.db_pass
            )
            cursor = conn.cursor()

            # Safety check
            dangerous = ["drop ", "truncate "]
            if any(word in sql_query.lower() for word in dangerous):
                QMessageBox.critical(self, "Blocked", "Dangerous SQL detected.")
                return

            # Split multi-statements safely
            statements = [s.strip() for s in sql_query.split(";") if s.strip()]

            result_output = ""

            for stmt in statements:
                cursor.execute(stmt)
                conn.commit()

                if cursor.description:
                    rows = cursor.fetchall()
                    result_output += "\n".join([str(row) for row in rows]) + "\n"

            if result_output:
                QMessageBox.information(self, "SQL Result", result_output[:2000])
            else:
                QMessageBox.information(self, "SQL Result", "All statements executed successfully.")

            cursor.close()
            conn.close()

        except Exception as e:
            QMessageBox.critical(self, "SQL Error", str(e))





